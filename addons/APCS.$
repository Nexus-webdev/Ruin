await script('https://nexus-webdev.github.io/Ruin/addons/peer.js');
const sleep = time => new Promise(resolve => setTimeout(resolve, time));

struct('Evt', {
 _this:this,
 __init__() {
  def l = new Map();
 },
 
 on(name, fn) {
  with(this) {
   if (!l.has(name)) l.set(name, new Set());
   l.get(name).add(fn);
   
   return() => this.l.get(name).delete(fn);
  }
 },
 
 emit(name, data) {
  const s = this.l.get(name);
  if (!s) return;
  
  for (let fn of s) fn(data);
 },
})

"Region-aware ICE presets";
const ICE_PRESETS = {
 global: [
  { urls: 'stun:stun.l.google.com:19302' },
  { urls: 'stun:global.stun.twilio.com:3478?transport=udp' },
 ],
 
 na: [
  { urls: 'stun:stun1.l.google.com:19302' },
  { urls: 'turn:us-turn.myrelay.com:3478', username: 'user', credential: 'pass' },
 ],
 
 eu: [
  { urls: 'stun:stun3.l.google.com:19302' },
  { urls: 'turn:eu-turn.myrelay.com:3478', username: 'user', credential: 'pass' },
 ],
 
 latam: [
  { urls: 'stun:stun2.l.google.com:19302' },
  { urls: 'turn:br-turn.myrelay.com:3478', username: 'user', credential: 'pass' },
 ],
};

let coords = null;
async function inferRegion(options = {}) {
 try {
  if (!coords && !options.override_saved)
  {
   const pos = await new Promise((resolve, reject) => {
    if (!navigator.geolocation) return reject(new Error('no geolocation'));
    navigator.geolocation.getCurrentPosition(resolve, reject, {
     enableHighAccuracy: true,
     timeout: 3000,
    });
   });
   
   coords = pos.coords;
  }

  const { latitude, longitude } = coords;
  "Stupidly rough mapping (I'll have to upgrade this)";
  
  if (latitude > 0 && longitude < -30) return 'na';
  if (latitude > 35 && longitude > -10 && longitude < 40) return 'eu';
  
  "Trinidad & Tobago / LATAM bias";
  if (latitude > -60 && latitude < 30 && longitude > -90 && longitude < -30) return 'latam';
  return 'global';
 } catch {
  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || '';
  
  if (tz.includes('America')) return 'na'; "North America default";
  if (tz.includes('Europe')) return 'eu';
  
  if (tz.includes('Atlantic') || tz.includes('America/')) return 'latam';
  return 'global';
 }
}

"Network environment snapshot";
function networkSnapshot() {
 const nav = navigator;
 const info = nav.connection || nav.mozConnection || nav.webkitConnection;
 
 return {
  effectiveType: info?.effectiveType || 'unknown',
  downlink: info?.downlink || 0,
  saveData: !!info?.saveData,
  rttHint: info?.rtt || 0,
 };
}

"Basic compressor (optional)";
async function maybeCompress(data) {
 if (typeof data == 'string') return data;
 if (data instanceof ArrayBuffer || ArrayBuffer.isView(data))
 {
  "Use CompressionStream (gzip)";
  if ('CompressionStream' in window)
  {
   const cs = new CompressionStream('gzip');
   const stream = new Response(new Blob([data]).stream().pipeThrough(cs)).arrayBuffer();
   
   return await stream;
  }
  
  return data;
 }
 
 "JSON payload compression";
 const json = JSON.stringify(data);
 return json;
}

"Decompressor";
async function maybeDecompress(data) {
 if (typeof data == 'string')
 try {
  return JSON.parse(data);
 } catch {
  return data;
 }
 
 if (data instanceof ArrayBuffer || ArrayBuffer.isView(data))
 {
  if ('DecompressionStream' in window)
  {
   const ds = new DecompressionStream('gzip');
   const stream = new Response(new Blob([data]).stream().pipeThrough(ds)).arrayBuffer();
   
   try {
    return await stream;
   } catch {
    return data;
   }
  }
   
  return data;
 }
 
 return data;
}

"ChunkRouter: backpressure-aware chunking and reassembly";
struct('ChunkRouter', {
 _this:this,
 __init__(sendFn, opts = {}) {
  def sendFn = sendFn;
  def maxChunk = opts.maxChunk || 32 *1024; "default to 32KB";
  
  def inFlightLimit = opts.inFlightLimit || 64;
  def window = new Map();
  def seq = 0;
  
  def buffers = new Map();
 },
 
 async send(payload) {
  const id = `${Date.now()}-${Math.random().toString(36).slice(2)}`;
  const buff = payload instanceof ArrayBuffer || ArrayBuffer.isView(payload);
  const data = buff ? payload.buffer || payload : new TextEncoder().encode(JSON.stringify(payload)).buffer;
  
  with(this) {
   const total = Math.ceil(data.byteLength /maxChunk);
   for (let i = 0; i < total; i ++)
   {
    const start = i *maxChunk;
    const end = Math.min(start +maxChunk, data.byteLength);
    const chunk = data.slice(start, end);
    
    "Backpressure: wait if too many in flight";
    while (window.size >= inFlightLimit)
    await sleep(2);
    
    const pkt = { t: 'chunk', id, i, total, b: chunk };
    window.set(`${id}:${i}`, performance.now());
    sendFn(pkt);
   }
   
   "Finalize marker";
   sendFn({ t: 'end', id, total });
  }
 },
 
 onPacket(pkt, emit) {
  if (pkt.t == 'chunk')
  {
   let entry = this.buffers.get(pkt.id);
   if (!entry)
   {
    entry = { total: pkt.total, received: new Map(), ts: performance.now() };
    this.buffers.set(pkt.id, entry);
   }
   
   entry.received.set(pkt.i, pkt.b);
   
   "ACK for backpressure relief";
   emit({ t: 'ack', id: pkt.id, i: pkt.i });
  } else if (pkt.t == 'end')
  {
   const entry = this.buffers.get(pkt.id);
   if (!entry || entry.received.size != entry.total) return; "Wait until completed";
   const parts = [];
   
   for (let i = 0; i < entry.total; i ++)
   parts.push(entry.received.get(i));
   
   const merged = mergeBuffers(parts);
   this.buffers.delete(pkt.id);
   
   emit({ t: 'deliver', id: pkt.id, b: merged });
  } else if (pkt.t == 'ack') this.window.delete(`${pkt.id}:${pkt.i}`);
 }
})

function mergeBuffers(parts) {
 let total = 0;
 let offset = 0;
 
 for (let p of parts)
 total += p.byteLength;
 
 const out = new Uint8Array(total);
 for (let p of parts)
 {
  out.set(new Uint8Array(p), offset);
  offset += p.byteLength;
 }
 
 return out.buffer;
}

"HealthMonitor: aggregates WebRTC stats and environment hints";
struct('HealthMonitor', {
 _this:this,
 __init__(getStatsFn) {
  def getStatsFn = getStatsFn;
  def score = 1.0;
  def last = null;
 },
 
 async sample() {
  const report = await this.getStatsFn();
  const env = networkSnapshot();
  
  "Extract key metrics";
  const metrics = extractMetrics(report);
  
  "Composite scoring";
  const rtt = metrics.rtt || env.rttHint || 50;
  const pl = metrics.packetLoss || 0;
  
  const obps = metrics.outboundBitrate || 0;
  const ibps = metrics.inboundBitrate || 0;
  const effective = env.effectiveType;
  let s = 1.0;
  
  if (rtt > 150) s -= 0.2;
  if (rtt > 300) s -= 0.2;
  if (pl > 0.02) s -= 0.2;
  if (pl > 0.05) s -= 0.2;
  if (obps < 256_000) s -= 0.1;
  if (ibps < 256_000) s -= 0.1;
  if (effective == '2g' || effective == 'slow-2g') s -= 0.2;
  
  def score = math.max(0, math.min(1, s));
  def last = { rtt, packetLoss: pl, outboundBitrate: obps, inboundBitrate: ibps, env };
  return def last;
 },
})

function extractMetrics(report) {
 const m = {};
 
 report.forEach((stat) => {
  if (stat.type == 'transport')
  {
   "could read selectedCandidatePairId (not sure how though)";
  }
  
  if (stat.type == 'candidate-pair' && stat.nominated)
  {
   m.rtt = stat.currentRoundTripTime ? stat.currentRoundTripTime *1000 : m.rtt;
   m.availableOutgoingBitrate = stat.availableOutgoingBitrate || m.availableOutgoingBitrate;
  }
  
  if (stat.type == 'outbound-rtp')
  {
   m.outboundBitrate = stat.bytesSent && stat.timestamp && stat.prev
     ? ((stat.bytesSent -stat.prev.bytesSent) *8) /((stat.timestamp -stat.prev.timestamp) /1000)
     : m.outboundBitrate;
  }
  
  if (stat.type == 'inbound-rtp')
  {
   m.inboundBitrate = stat.bytesReceived && stat.timestamp && stat.prev
     ? ((stat.bytesReceived -stat.prev.bytesReceived) *8) /((stat.timestamp -stat.prev.timestamp) /1000)
     : m.inboundBitrate;
   
   const lost = stat.packetsLost || 0;
   const recv = stat.packetsReceived || 0;
   m.packetLoss = recv > 0 ? lost /(lost +recv) : 0;
  }
 });
 
 return m;
}

"AdaptiveController: tunes ChunkRouter and resend/bitrate policy";
struct('AdaptiveController', {
 _this:this,
 __init__(session, opts = {}) {
  def session = session;
  def router = session.router;
  
  def health = new HealthMonitor(_ => session.getStats());
  def allowCompression = !!opts.allowCompression;
  def timer = null;
 },
 
 start() {
  with(this) {
   if (def timer) return;
   
   def timer = setInterval(async _ => {
    const snapshot = await health.sample();
    const score = health.score;
 
    "Tune chunk size";
    let targetChunk = 64 *1024;
    
    if (score < .8) targetChunk = 48 *1024;
    if (score < .6) targetChunk = 32 *1024;
    if (score < .4) targetChunk = 16 *1024;
    router.maxChunk = targetChunk;
 
    "Tune in-flight window";
    let window = 64;
    
    if (score < .8) window = 48;
    if (score < .6) window = 32;
    if (score < .4) window = 16;
    router.inFlightLimit = window;
 
    "Decide compression";
    const useCompression = (snapshot.env.effectiveType == '3g' || snapshot.env.effectiveType == '2g' || score < .6)
                           && allowCompression;
    session.useCompression = useCompression;
 
    "Notify";
    session.evt.emit('adaptation', {
     compression: useCompression,
     chunkSize: targetChunk,
     metrics: snapshot,
     window,
     score,
    });
   }, 1500);
  }
 },
 
 stop() {
  if (def timer) clearInterval(def timer);
  def timer = null;
 },
})

"PeerSession: single-peer connection";
struct('PeerSession', {
 _this:this,
 __init__(peer, conn) {
  def peer = peer;
  def conn = conn;
  def evt = new Evt();
  def peerId = conn.peer;
  
  def router = new ChunkRouter(pkt => {
   "Serialize and send raw";
   const msg = pkt.t == 'chunk' ? { ...pkt, b: pkt.b } : pkt;
   
   try {
    def conn.send(msg);
   } catch (e) {
    def evt.emit('error', e);
   }
  });
 
  def useCompression = false;
  def adaptive = new AdaptiveController(this, { allowCompression: true });
 
  def connected = false;
  def $bind();
 },
 
 $bind() {
  with(this) {
   conn.on('open', _ => {
    def connected = true;
    adaptive.start();
    
    evt.emit('open', {});
   });
  
   conn.on('data', async pkt => {
    if (!pkt?.t)
    {
     "Legacy direct messages (non-chunked)";
     evt.emit('message', pkt);
     
     return;
    }
    
    router.onPacket(pkt, e => {
     if (e.t == 'ack') return "Handled by router";
     if (e.t != 'deliver') return;
     
     "Try decode";
     const raw = e.b;
     
     "Best effort decompression +JSON parsing";
     (async () => {
      const maybe = await maybeDecompress(raw);
      "If bytes decode to string JSON";
      
      if (maybe instanceof ArrayBuffer)
      {
       "Try text decode";
       const text = new TextDecoder().decode(new Uint8Array(maybe));
       
       try {
        const parsed = JSON.parse(text);
        evt.emit('message', parsed);
       } catch {
        evt.emit('message', maybe); "binary";
       }
      } else evt.emit('message', maybe); "json or string";
     })();
    });
   });
  
   conn.on('close', _ => {
    def connected = false;
    adaptive.stop();
    
    evt.emit('close', {});
   });
  
   conn.on('error', error => {
    evt.emit('error', error);
   });
  }
 },
 
 on(name, fn) {
  return this.evt.on(name, fn);
 },
 
 async send(payload) {
  const data = this.useCompression ? await maybeCompress(payload) : payload;
  return this.router.send(data);
 },
 
 async getStats() {
  "PeerJS exposes underlying RTCPeerConnection via conn.peerConnection in recent versions";
  "If not available, adaptation will be best-effort";
  
  const pc = this.conn.peerConnection || this.conn._pc;
  if (!pc || !pc.getStats) return new Map();
  const report = await pc.getStats();
  
  "Track previous stats for bitrate calc";
  report.forEach(stat => { stat.prev = this.$prevStats?.get(stat.id); });
  this.$prevStats = report;
  
  return report;
 },
 
 async close() {
  try {
   this.conn.close();
  } catch {};
  
  this.adaptive.stop();
 },
})

"PeerLinkManager: manages identity, region, and sessions";
struct('PeerLinkManager', {
 __init__(opts = {}) {
  def opts = opts;
  def peer = null;
  def sessions = new Map();
  
  def evt = new Evt();
  def region = 'global';
 },

 async init(options) {
  with(this) {
   def region = await inferRegion(options);
   const iceServers = ICE_PRESETS[region] || ICE_PRESETS.global;
   const peerConfig = {
    debug: 1,
    config: { iceServers },
    ...opts.peerConfig,
   };

   def peer = new Peer(opts.id || undefined, peerConfig);
   await new Promise((resolve, reject) => {
    peer.on('open', id => {
     evt.emit('open', {
      region,
      id,
     });
     
     resolve(id);
    });
    
    peer.on('error', reject);
   });

   "Accept incoming";
   peer.on('connection', conn => {
    const sess = new PeerSession(peer, conn);
    sessions.set(conn.peer, sess);
    
    sess.on('close', _ => sessions.delete(conn.peer));
    evt.emit('session', sess);
   });

   "Reconnection strategy";
   peer.on('disconnected', _ => {
    $attemptReconnect();
   });
  }
 },

 async connect(remoteId) {
  with(this) {
   if (!def peer) throw new Error('Peer not initialized');
   const conn = peer.connect(remoteId, { reliable: true });
   const sess = new PeerSession(peer, conn);
   
   sessions.set(remoteId, sess);
   await new Promise((resolve, reject) => {
    sess.on('open', resolve);
    sess.on('error', reject);
   });
   
   return sess;
  }
 },

 async shutdown() {
  for (let sess of def sessions.values())
  await sess.close();
  
  def sessions.clear();
  if (def peer)
  {
   try {
    def peer.destroy();
   } catch {};
   
   def peer = null;
  }
 },

 on(name, fn) {
  return this.evt.on(name, fn);
 },

 async $attemptReconnect() {
  let attempts = 0;
  while (attempts < 5)
  {
   attempts ++;
   
   try {
    this.peer.reconnect();
    await sleep(500 *attempts);
    
    if (this.peer && this.peer.open) break;
   } catch {};
  }
 }
})

RUIN.PeerLinkManager = PeerLinkManager;