struct('GistChannel', {
 construct(gistId, token, write = 'ruin-message.json', read = 'py-message.json') {
  def gistId = gistId;
  def token = token;
  def filename = write;
  def filenameB = read;
  def apiUrl = `https://api.github.com/gists/${def gistId}`;
  
  def headers = {
   'Authorization': `token ${def token}`,
   'Accept': 'application/vnd.github.v3+json',
   'Content-Type': 'application/json'
  };
 },
 
 send(data) {
  return new Promise(async resolve => {
   const payload = {
    files: {
     [this.filename]: {
      content: json.stringify(data, null, 2),
     }
    }
   };
   
   const res = await fetch(this.apiUrl, {
    method: 'PATCH',
    headers: this.headers,
    body: json.stringify(payload),
   });
   
   resolve(res.ok);
  })
 },
 
 receive() {
  return new Promise(async resolve => {
   const res = await fetch(this.apiUrl, {
    method: 'GET',
    headers: this.headers,
   });
  
   if (!res.ok) return null;
   const gist = await res.json();
   const content = gist.files?.[this.filenameB]?.content || '{}';
  
   try {
    resolve(json.parse(content));
   } catch {
    resolve(null);
   }
  })
 },
 
 watch(callback, interval = 500) {
  const controller = new AbortController();
  let last = null;

  const poll = async _ => {
   if (controller.signal.aborted) return;
   const msg = await this.receive();
   
   if (msg && json.stringify(msg) != json.stringify(last))
   {
    if (msg.from_python) callback(msg);
    last = msg;
   }
   
   setTimeout(poll, interval);
  };

  poll();
  return controller;
 },
})